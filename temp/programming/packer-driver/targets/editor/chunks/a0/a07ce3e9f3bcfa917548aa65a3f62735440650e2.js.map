{"version":3,"sources":["file:///E:/CocosProjects/Color/assets/ts-gameframework-master/servers/src/shared/tsgfServer/match/MatchRequestTerminal.ts"],"names":["MatchRequestTerminal","EMatchFromType","ErrorCodes","Result","MatchRequestHelper","initMatchRequest","constructor","getRedisClient","useStateServer","reqHelper","matchReqsResultCallback","Map","start","startListenMatchResult","notify","procGlobalMatchResultNotify","stop","stopListenMatchResult","resultCallback","get","request","matchReqId","result","requestMatch","appId","matchParams","callback","limit","req","pushRequestMatchProc","set","delete","removeMatchRequestAndResult","buildSucc","queryMatch","Error","getMatchRequestResult","cancelMatch","currPlayerId","getMatchRequest","matchFromType","RoomJoinUs","Player","fromInfo","matchFromInfo","playerIds","includes","buildErr","MatchPermissionDenied","RoomAllPlayers","pushCancelMatchProc"],"mappings":"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","sourcesContent":["\nimport { EMatchFromType, IMatchResult } from \"../../tsgf/match/Models\";\nimport { ErrorCodes, IResult, Result } from \"../../tsgf/Result\";\nimport { MatchRequestHelper } from \"./MatchRequestHelper\";\nimport { IMatchRequestParams, IMatchResultNotify, initMatchRequest } from \"./Models\";\nimport { IRedisClient } from \"../redisHelper\";\n\nexport type MatchRequestFinishEvent = (result: IResult<IMatchResult>) => void;\n\n/**匹配请求服务终端，由大厅或游戏服务实例使用。\n * 大厅服务器无状态服务使用\n * 游戏服务器有状态服务使用，让房间中的玩家也可以发起匹配并实时收到匹配结果并广播\n * */\nexport class MatchRequestTerminal {\n\n    private reqHelper: MatchRequestHelper;\n    /**是否启用状态服务，启用则本地不存储当前请求的状态，统一查询redis，HTTP服务部署用的*/\n    private useStateServer: boolean;\n    /**当前匹配中请求的结果回调，请求ID=>结果回调, 但如果是分布式HTTP服务（无状态），则不能将临时数据保存在服务器*/\n    protected matchReqsResultCallback: Map<string, MatchRequestFinishEvent> = new Map<string, MatchRequestFinishEvent>();\n\n\n    /**\n     *\n     * @param getRedisClient\n     * @param useStateServer 是否启用状态服务部署，无状态则本地不存储当前请求的状态，统一查询redis，HTTP服务部署用的\n     */\n    constructor(getRedisClient: (reuseClient: boolean) => Promise<IRedisClient>, useStateServer: boolean) {\n        this.reqHelper = new MatchRequestHelper(getRedisClient);\n        this.useStateServer = useStateServer;\n    }\n\n    public async start(): Promise<void> {\n        if (this.useStateServer) {\n            await this.reqHelper.startListenMatchResult((notify) => {\n                this.procGlobalMatchResultNotify(notify);\n            });\n        }\n    }\n    public async stop(): Promise<void> {\n        if (this.useStateServer) {\n            await this.reqHelper.stopListenMatchResult();\n        }\n    }\n    protected procGlobalMatchResultNotify(notify: IMatchResultNotify) {\n        let resultCallback = this.matchReqsResultCallback.get(notify.request.matchReqId);\n        if (resultCallback) {\n            resultCallback(notify.result);\n        }\n    }\n\n\n\n    /**\n     * 请求一次匹配, 返回匹配请求ID，用于查询请求结果\n     *\n     * @public\n     * @param appId\n     * @param matchParams\n     * @param callback 只有状态服务的终端(useStateServer=true),才可以设置结果回调,如大厅服务需要自己轮询查询结果\n     * @param limit 是否限制请求参数, 来自服务端构建的则不需要限制, 比如房间招人匹配\n     * @returns\n     */\n    public async requestMatch(appId: string, matchParams: IMatchRequestParams, callback?: (result: IResult<IMatchResult>) => void, limit = true)\n        : Promise<IResult<string>> {\n        let req = initMatchRequest(matchParams, limit);\n        await this.reqHelper.pushRequestMatchProc(appId, req);\n        if (this.useStateServer) {\n            //如果是有状态服务，则保存到本地，设置回调，接收到后回调\n            if (callback) {\n                //有设置回调才这样处理\n                this.matchReqsResultCallback.set(req.matchReqId, (result) => {\n                    this.matchReqsResultCallback.delete(req.matchReqId);\n                    // 结果回来了就\n                    this.reqHelper.removeMatchRequestAndResult(appId, req.matchReqId);\n                    callback(result);\n                });\n            }\n        }\n        return Result.buildSucc(req.matchReqId);\n    }\n\n    /**\n     * [无状态服务专用] 查询匹配结果，如果有结果则完成本次匹配请求（会清理本次请求的所有数据，即下次再查询就获取不到结果了）\n     *\n     * @public\n     * @param appId\n     * @param matchReqId\n     * @returns 还没有结果则返回null，如果有结果则返回结果的IResult\n     */\n    public async queryMatch(appId: string, matchReqId: string): Promise<IResult<IMatchResult> | null> {\n        if (this.useStateServer) {\n            throw Error(\"有状态服务，不可单独使用查询，因为请求时已经设置了回调，结果将走回调，这里查询不到！\");\n        }\n        let result = await this.reqHelper.getMatchRequestResult(appId, matchReqId);\n        if (!result) return null;\n        // 查询到结果了, 把匹配请求和结果数据都删除\n        await this.reqHelper.removeMatchRequestAndResult(appId, matchReqId);\n        return result;\n    }\n    /**\n     * 取消匹配\n     *\n     * @public\n     * @param appId\n     * @param matchReqId\n     * @returns\n     */\n    public async cancelMatch(appId: string, matchReqId: string, currPlayerId?: string): Promise<IResult<null>> {\n\n        let req = await this.reqHelper.getMatchRequest(appId, matchReqId);\n        if (!req) {\n            //匹配请求已经不存在，则直接认为成功\n            return Result.buildSucc(null);\n        }\n        switch (req.matchFromType) {\n            case EMatchFromType.RoomJoinUs:\n                //return Result.buildErr('房间匹配由房间属性自动启动匹配，不能手动开始匹配或取消！', ErrorCodes.ParamsError);\n                break;\n            case EMatchFromType.Player: {\n                let fromInfo = req.matchFromInfo;\n                if (!currPlayerId || !fromInfo.playerIds.includes(currPlayerId)) {\n                    return Result.buildErr('只有匹配的玩家才可以取消匹配！', ErrorCodes.MatchPermissionDenied);\n                }\n                break;\n            }\n            case EMatchFromType.RoomAllPlayers: {\n                let fromInfo = req.matchFromInfo;\n                if (!currPlayerId || !fromInfo.playerIds.includes(currPlayerId)) {\n                    return Result.buildErr('只有匹配的玩家才可以取消匹配！', ErrorCodes.MatchPermissionDenied);\n                }\n                break;\n            }\n        }\n\n        //将取消匹配操作推入队列，让匹配服务器接收处理(清理数据)\n        await this.reqHelper.pushCancelMatchProc(appId, matchReqId);\n        return Result.buildSucc(null);\n    }\n\n}"]}