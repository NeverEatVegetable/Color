{"version":3,"sources":["file:///E:/CocosProjects/Color/assets/ts-gameframework-master/servers/src/gameServerCluster/GameServerClusterMgr.ts"],"names":["GameServerClusterMgr","path","ClusterMgr","GameServerHelper","Result","gameClusterServiceProto","serviceProto","GameServerRoomMgr","arrWinner","constructor","getNodesCfg","getTerminalCfg","serverOption","getRedisClient","clusterTypeKey","gameServerTaskCancel","roomMgr","server","flows","preApiCallFlow","push","v","getGameClusterServer","preMsgCallFlow","postDisconnectFlow","conn","nodeId","dismissServerRooms","start","autoImplementApi","resolve","__dirname","stop","cancel","notifyGameServerDismissRoom","roomRegInfo","ret","assignTask","gameServerNodeId","roomId","succ","buildSucc","allotGameServerByInfos","allServerNodeList","getServerRooms","createRoomPara","canAllotNodes","sort","a","b","info","clientCount","s","allotRules","limitRoomCountRules","length","rules","filter","r","roomType","maxPlayers","minLimit","winner","item","limitRoomCount","rooms","serverNodeId","currRoomCount","count","room","allotGameServer","buildRoomOnlineInfo","gameServerInfo","getNodeById","roomOnlineInfo"],"mappings":"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","sourcesContent":["import { ApiCallWs, MsgCallWs, WsConnection, WsServer, WsServerOptions } from \"tsrpc\";\nimport * as path from \"path\";\nimport { ClusterMgr, IClusterNodeInfo } from \"../shared/tsgfServer/cluster/ClusterMgr\";\nimport { GetRedisClient } from \"../shared/tsgfServer/redisHelper\";\nimport { IGameServerInfoInServer } from \"../shared/tsgfServer/game/Models\";\nimport { GameServerHelper } from \"../shared/tsgfServer/game/GameServerHelper\";\nimport { IClusterNodeCfg, IClusterTerminalCfg } from \"../ServerConfig\";\nimport { ICancelable } from \"../shared/tsgf/ICancelable\";\nimport { IRoomRegInfo } from \"../shared/tsgfServer/room/Models\";\nimport { IResult, Result } from \"../shared/tsgf/Result\";\nimport { ServiceType as GameClusterServiceType, serviceProto as gameClusterServiceProto } from \"../shared/tsgfServer/gameCluster/protocols/serviceProto\";\nimport { GameServerRoomMgr } from \"./GameServerRoomMgr\";\nimport { ICreateRoomPara, IRoomOnlineInfo } from \"../shared/tsgf/room/IRoomInfo\";\nimport { arrWinner } from \"../shared/tsgf/Utils\";\n/**\n * 游戏集群服务器API专用的ApiCall类型，可用于获取Game集群服务对象\n * @date 2022/4/26 - 16:21:57\n *\n * @typeParam req\n * @typeParam res\n */\nexport type GameClusterApiCall<req, res> = ApiCallWs<req, res, GameClusterServiceType> & {\n    getGameClusterServer: () => GameServerClusterMgr;\n};\n/**\n * 游戏集群服务器Msg专用的MsgCall类型，可用于获取Game集群服务对象\n * @date 2022/4/26 - 16:21:57\n *\n * @typedef {GameClusterMsgCall}\n * @typeParam msg\n */\nexport type GameClusterMsgCall<msg> = MsgCallWs<msg, GameClusterServiceType> & {\n    getGameClusterServer: () => GameServerClusterMgr;\n};\n\n/**游戏服务端的客户端连接*/\nexport type ClientConnection = WsConnection<GameClusterServiceType>;\n\n/**游戏的websocket服务类型*/\nexport type GameWsServer = WsServer<GameClusterServiceType>;\n\n/**游戏服务器管理节点，依赖redis功能*/\nexport class GameServerClusterMgr extends ClusterMgr<GameClusterServiceType, IGameServerInfoInServer>{\n\n    protected gameServerTaskCancel?: ICancelable;\n    public readonly roomMgr: GameServerRoomMgr = new GameServerRoomMgr(this);\n\n    constructor(\n        getNodesCfg: () => Promise<IClusterNodeCfg[]>,\n        getTerminalCfg: () => Promise<IClusterTerminalCfg[] | undefined>,\n        serverOption: Partial<WsServerOptions<GameClusterServiceType>>,\n        getRedisClient: GetRedisClient) {\n        super(gameClusterServiceProto, GameServerHelper.clusterTypeKey, getNodesCfg, getTerminalCfg, serverOption, getRedisClient);\n        //让Call能获取到本服务实例\n        this.server.flows.preApiCallFlow.push((v: GameClusterApiCall<any, any>) => {\n            v.getGameClusterServer = () => this;\n            return v;\n        });\n        this.server.flows.preMsgCallFlow.push((v: GameClusterMsgCall<any>) => {\n            v.getGameClusterServer = () => this;\n            return v;\n        });\n        this.server.flows.postDisconnectFlow.push((v) => {\n            if (v.conn.nodeId) {\n                this.roomMgr.dismissServerRooms(v.conn.nodeId);\n            }\n            return v;\n        });\n    }\n\n    public override async start() {\n        //额外注册api目录下的接口\n        await this.autoImplementApi(gameClusterServiceProto, path.resolve(__dirname, 'api'));\n        await super.start();\n    }\n    public override async stop() {\n        await this.gameServerTaskCancel?.cancel();\n        await super.stop();\n    }\n    /**\n     * 通知游戏服务器解散房间\n     */\n    public async notifyGameServerDismissRoom(roomRegInfo: IRoomRegInfo): Promise<IResult<null>> {\n        let ret = await this.assignTask(roomRegInfo.gameServerNodeId, 'DismissRoom', roomRegInfo.roomId);\n        if (!ret.succ) return ret;\n        return Result.buildSucc(null);\n    }\n\n\n\n    /**\n     * 按规则自动分配一个合适的服务器, 没有合适的返回null\n     * @param createRoomPara 指定分配规则标识, 放空则分配最少客户端的服务器\n     * @returns game server \n     */\n    public async allotGameServerByInfos(allServerNodeList: IClusterNodeInfo<IGameServerInfoInServer>[], getServerRooms: (serverNodeId: string) => Promise<IRoomRegInfo[]>, createRoomPara: ICreateRoomPara): Promise<IGameServerInfoInServer | null> {\n        let canAllotNodes: IClusterNodeInfo<IGameServerInfoInServer>[] = [];\n        //按在线客户端升序\n        allServerNodeList = allServerNodeList.sort((a, b) => a.info.clientCount - b.info.clientCount);\n        for (const s of allServerNodeList) {\n            // 根据各服务器配置的分配规则进行筛选\n            if (s.info.allotRules?.limitRoomCountRules?.length) {\n                // 有配置限制房间数规则, 则根据当前创建房间请求匹配规则\n                let rules = s.info.allotRules.limitRoomCountRules.filter(r => {\n                    // 有配置且不符合的过滤\n                    if (r.roomType && r.roomType !== createRoomPara.roomType) return false;\n                    if (r.maxPlayers && r.maxPlayers !== createRoomPara.maxPlayers) return false;\n                    // 其他的视为匹配的规则\n                    return true;\n                });\n                if (!rules.length) {\n                    // 没匹配中的规则,视本服务器不可分配\n                    continue;\n                }\n                // 取限制房间数最小的那个配置\n                let minLimit = arrWinner(rules,\n                    (winner, item) => winner.limitRoomCount < item.limitRoomCount ? winner : item)!;\n                // 检查现有房间符合规则的数量\n                let rooms = await getServerRooms(s.info.serverNodeId);\n                if (!rooms) continue;\n                let currRoomCount = rooms.count(room => {\n                    if (minLimit.roomType && minLimit.roomType !== room.roomType) return false;\n                    if (minLimit.maxPlayers && minLimit.maxPlayers !== room.maxPlayers) return false;\n                    return true;\n                });\n                if (currRoomCount >= minLimit.limitRoomCount) {\n                    // 本创建房间请求匹配的规则,对应现有的房间已经满额了, 本服务器不可分配\n                    continue;\n                }\n            }\n            // 上面规则都没配置, 或者都通过了检测, 则可以分配!\n            canAllotNodes.push(s);\n        }\n        if (!canAllotNodes.length) {\n            // 没有可以分配的服务器\n            return null;\n        }\n\n        // 如果多个,则取一个连接数最少的\n        let allotGameServer = arrWinner(canAllotNodes, (winner, item) => winner.info.clientCount > item.info.clientCount ? item : winner)!;\n        return allotGameServer.info;\n    }\n\n    /**\n     * 生成房间在线信息，如果房间指向的服务器不可用，则房间在线信息里的服务器连接地址为undefined\n     * @param roomRegInfo \n     * @returns room online info \n     */\n    public buildRoomOnlineInfo(roomRegInfo: IRoomRegInfo): IRoomOnlineInfo {\n        let gameServerInfo = this.getNodeById(roomRegInfo.gameServerNodeId);\n        let roomOnlineInfo = GameServerHelper.buildRoomOnlineInfo(roomRegInfo, gameServerInfo?.info);\n        return roomOnlineInfo;\n    }\n}"]}