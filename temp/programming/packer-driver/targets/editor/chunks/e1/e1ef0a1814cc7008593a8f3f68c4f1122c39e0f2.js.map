{"version":3,"sources":["file:///E:/CocosProjects/Color/assets/ts-gameframework-master/servers/src/gameServer/FrameSyncExecutor.ts"],"names":["FrameSyncExecutor","localSetImmediate","setImmediate","fn","setTimeout","syncing","_syncing","nextSyncFrameIndex","_nextSyncFrameIndex","prevSyncFrameIndexArrIndex","_prevSyncFrameIndexArrIndex","maxSyncFrameIndex","_maxSyncFrameIndex","allFrames","_allFrames","allFrameIndexMapArrIndex","_allFrameIndexMapArrIndex","lastStateData","_lastStateData","lastStateFrameIndex","_lastStateFrameIndex","constructor","onSyncOneFrame","syncFrameRate","_syncFrameRate","_syncFrameIntervalMs","_frameUpdateHD","_prevFrameTime","_startFrameTime","_runFrameAndNextBind","_syncOneFrameTempMsg","syncFrame","frameIndex","playerInputs","dt","runFrameAndNext","bind","stopSyncFrame","clearTimeout","startSyncFrame","Date","now","_syncOneFrameHandler","nextFrameRunTime","waitMs","currFrameIndex","currFrameArrIndex","length","syncStateData","stateData","stateFrameIndex","addPlayerInpFrame","playerId","inpFrameType","setOthersProp","nextFrameArrIndex","nextFrame","splice","push","inpFrame","inputFrameType","buildAfterFrames","startFrameIndex","undefined","aFrames","requestFrames","msg","afterFrames","afterStartFrameIndex","afterEndFrameIndex","serverSyncFrameRate","beginFrameIndex","endFrameIndex","i","arrIndex","frame"],"mappings":"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","sourcesContent":["\nimport { MsgPlayerInpFrame } from \"../shared/gameClient/protocols/MsgPlayerInpFrame\";\nimport { MsgNotifySyncFrame } from \"../shared/gameClient/protocols/MsgNotifySyncFrame\";\nimport { EPlayerInputFrameType, IAfterFrames, IGameSyncFrame, IFramePlayerInput, IPlayerInputOperate } from \"../shared/tsgf/room/IGameFrame\";\n\n//兼容的SetImmediate\nconst localSetImmediate = typeof (setImmediate) !== 'undefined' ? setImmediate : (fn: () => any) => setTimeout(fn, 0);\n\n\nexport class FrameSyncExecutor {\n\n    /**同步帧率(每秒多少帧),默认每秒60帧*/\n    private _syncFrameRate: number;\n    /**每帧的理论间隔秒数*/\n    private _syncFrameIntervalMs: number;\n    /**帧同步的定时器句柄*/\n    private _frameUpdateHD!: NodeJS.Timeout;\n    /**上一帧的时间戳*/\n    private _prevFrameTime: number = 0;\n    /**开始同步帧的时间戳*/\n    private _startFrameTime: number = 0;\n    private _runFrameAndNextBind: () => void;\n    /**同步每一帧的临时消息*/\n    private _syncOneFrameTempMsg: MsgNotifySyncFrame = {\n        syncFrame: { frameIndex: 0, playerInputs: null },\n        dt: 0,\n    };\n    /**同步每一帧需要的处理器*/\n    private onSyncOneFrame: (msg: MsgNotifySyncFrame) => void;\n\n    /**当前是否在执行帧同步中, 只有内部或者单元测试可以访问!*/\n    _syncing: boolean = false;\n    /**当前是否在执行帧同步中*/\n    get syncing() {\n        return this._syncing;\n    }\n\n    /**下次同步的帧索引,从0开始, 执行完一次帧同步后值会更新为下一帧的帧索引*/\n    private _nextSyncFrameIndex = 0;\n    /**下次同步的帧索引,从0开始, 执行完一次帧同步后值会更新为下一帧的帧索引*/\n    get nextSyncFrameIndex() {\n        return this._nextSyncFrameIndex;\n    }\n    /**上次同步的帧索引在帧数组中的索引位置, 即首次为-1, 只有非空帧时才前进一位*/\n    private _prevSyncFrameIndexArrIndex = -1;\n    /**上次同步的帧索引在帧数组中的索引位置, 即首次为-1, 只有非空帧时才前进一位*/\n    get prevSyncFrameIndexArrIndex() {\n        return this._prevSyncFrameIndexArrIndex;\n    }\n\n    /**当前最大帧索引,自动同步帧和输入帧放下一帧,都会推动和同步最大帧索引*/\n    private _maxSyncFrameIndex = -1;\n    /**当前最大帧索引,自动同步帧和输入帧放下一帧,都会推动和同步最大帧索引*/\n    get maxSyncFrameIndex() {\n        return this._maxSyncFrameIndex;\n    }\n\n    /**所有帧数据,不存储空帧 */\n    private _allFrames: IGameSyncFrame[] = [];\n    /**所有帧数据 */\n    get allFrames() {\n        return this._allFrames;\n    }\n\n    /**所有帧索引对应数组索引, 如果指向空帧,则为上一个最近的数组索引 */\n    private _allFrameIndexMapArrIndex: number[] = [];\n    get allFrameIndexMapArrIndex() {\n        return this._allFrameIndexMapArrIndex;\n    }\n\n    /**当前最后一次游戏状态数据*/\n    private _lastStateData: any = {};\n    /**当前最后一次游戏状态数据*/\n    get lastStateData() {\n        return this._lastStateData;\n    }\n\n    /**当前最后一次游戏状态数据来自哪一帧(即从下一帧开始追帧)*/\n    private _lastStateFrameIndex = -1;\n    /**当前最后一次游戏状态数据来自哪一帧(即从下一帧开始追帧)*/\n    get lastStateFrameIndex() {\n        return this._lastStateFrameIndex;\n    }\n\n    constructor(onSyncOneFrame: (msg: MsgNotifySyncFrame) => void, syncFrameRate = 30) {\n        this._syncFrameRate = syncFrameRate;\n        this._syncFrameIntervalMs = 1000 / syncFrameRate;\n        this.onSyncOneFrame = onSyncOneFrame;\n        this._runFrameAndNextBind = this.runFrameAndNext.bind(this);\n    }\n\n\n    /**\n     * 停止同步游戏帧\n     */\n    public stopSyncFrame(): void {\n        this._syncing = false;\n        clearTimeout(this._frameUpdateHD);\n\n        this._lastStateData = {};\n        this._lastStateFrameIndex = -1;\n        this._allFrames = [];\n        this._allFrameIndexMapArrIndex = [];\n        this._nextSyncFrameIndex = 0;\n        this._prevSyncFrameIndexArrIndex = -1;\n        this._maxSyncFrameIndex = -1;\n    }\n    /**\n     * 开始同步游戏帧(从下个间隔开始发送)\n     */\n    public startSyncFrame(): void {\n        if (!this._syncing) {\n            this._startFrameTime = this._prevFrameTime = Date.now();\n            //首次按理论帧率开始\n            this._frameUpdateHD = setTimeout(this._runFrameAndNextBind, this._syncFrameIntervalMs);\n            this._syncing = true;\n        }\n    }\n    private runFrameAndNext(): void {\n        const now = Date.now();\n        this._syncOneFrameTempMsg.dt = (now - this._prevFrameTime) / 1000;\n        this._syncOneFrameHandler();\n        this._prevFrameTime = now;\n\n        //开始计算下一帧应该开始的时间\n\n        //先计算,从开始同步到下一帧理论应该执行的时间戳\n        const nextFrameRunTime = this._startFrameTime + this._nextSyncFrameIndex * this._syncFrameIntervalMs;\n        //再计算出当前时间再过多久到\n        let waitMs = nextFrameRunTime - now;\n        //当然, 也可能是负数(即在这现在之前就应该跑到了, 但都超过时间了, 则置为0, 尽最大努力执行)\n        if (waitMs < 0) {\n            //需要追帧了, 则用最快的事件循环, 因为setTimeout0 相当于setTimeout4\n            localSetImmediate(this._runFrameAndNextBind);\n        } else {\n            this._frameUpdateHD = setTimeout(this._runFrameAndNextBind, waitMs);\n        }\n\n    }\n\n\n    /**\n     * 同步下个游戏帧的处理器, 正常由内部定时器调用, 只有在单元测试时可以让外部调用进行测试\n     */\n    _syncOneFrameHandler(): void {\n        //本次要同步的帧索引\n        let currFrameIndex = this._nextSyncFrameIndex;\n        /**下一帧的数组索引,因为可能是空帧,所以本索引可能指向不对(可能为后面某个非空帧的索引)!*/\n        let currFrameArrIndex = this._prevSyncFrameIndexArrIndex + 1;\n        //最大帧索引推进\n        if (this._nextSyncFrameIndex > this._maxSyncFrameIndex) {\n            this._maxSyncFrameIndex = this._nextSyncFrameIndex;\n        }\n        //下一帧索引推进\n        this._nextSyncFrameIndex++;\n        if (currFrameArrIndex >= this._allFrames.length\n            || currFrameIndex < this._allFrames[currFrameArrIndex].frameIndex) {\n            //数组长度不够, 或者 下一位帧的帧索引还没到,则视为空帧\n            this._syncOneFrameTempMsg.syncFrame = { frameIndex: currFrameIndex, playerInputs: null };\n            //本帧索引,对应的还是上一个数组索引\n            this._allFrameIndexMapArrIndex[currFrameIndex] = this._prevSyncFrameIndexArrIndex;\n        } else {\n            //就是这个顺位帧了!\n            this._syncOneFrameTempMsg.syncFrame = this._allFrames[currFrameArrIndex];\n            //本帧的数组索引有效,记录,下个帧从这里往后找\n            this._prevSyncFrameIndexArrIndex = currFrameArrIndex;\n            //本帧索引对应的数组索引更新\n            this._allFrameIndexMapArrIndex[currFrameIndex] = currFrameArrIndex;\n        }\n        //触发事件\n        this.onSyncOneFrame(this._syncOneFrameTempMsg);\n    }\n\n\n    /**\n     * 同步游戏状态数据\n     * @param stateData \n     * @param stateFrameIndex \n     */\n    public syncStateData(stateData: any, stateFrameIndex: number): void {\n        this._lastStateData = stateData;\n        this._lastStateFrameIndex = stateFrameIndex;\n    }\n\n    /**\n     * [同步中才有效]添加玩家的输入帧到下一帧\n     * @param playerId \n     * @param inpFrameType 输入帧类型\n     * @param setOthersProp 自行设置额外字段\n     */\n    public addPlayerInpFrame(playerId: string, inpFrameType: EPlayerInputFrameType,\n        setOthersProp?: (inpFrame: IFramePlayerInput) => void): void {\n        if (!this._syncing) return;\n        //收到的输入下一帧生效\n        let frameIndex = this._nextSyncFrameIndex;\n        /**下一帧的数组索引,因为要加入输入帧,所以本索引一定存在!*/\n        let nextFrameArrIndex = this._prevSyncFrameIndexArrIndex + 1;\n        //更新最大帧索引\n        if (frameIndex > this._maxSyncFrameIndex) this._maxSyncFrameIndex = frameIndex;\n\n        let nextFrame: IGameSyncFrame | undefined;\n        if (this._allFrames.length > nextFrameArrIndex) {\n            //数组长度够索引\n            if (this._allFrames[nextFrameArrIndex].frameIndex === frameIndex) {\n                //并且数组下一位元素刚好就是下一帧\n                nextFrame = this._allFrames[nextFrameArrIndex];\n            } else {\n                //不是,说明中间是空帧,创建一个并插入\n                nextFrame = {\n                    frameIndex: frameIndex,\n                    playerInputs: [],\n                };\n                this._allFrames.splice(nextFrameArrIndex, 0, nextFrame);\n                //新增帧,更新该帧索引对应的数组索引\n                this._allFrameIndexMapArrIndex[frameIndex] = nextFrameArrIndex;\n            }\n        } else {\n            //数组长度不够索引下一位, 需要生成新的一帧\n            nextFrame = {\n                frameIndex: frameIndex,\n                playerInputs: [],\n            };\n            this._allFrames.push(nextFrame);\n            nextFrameArrIndex = this._allFrames.length - 1;\n            //新增帧,更新该帧索引对应的数组索引\n            this._allFrameIndexMapArrIndex[frameIndex] = nextFrameArrIndex;\n        }\n\n        //生成玩家输入\n        let inpFrame: IFramePlayerInput = {\n            playerId: playerId,\n            inputFrameType: inpFrameType,\n        };\n        //如果有自定义属性\n        if (setOthersProp) setOthersProp(inpFrame);\n        //玩家输入加入到下一帧中\n        nextFrame.playerInputs!.push(inpFrame);\n    }\n\n    /**\n     * 获取给连接发追帧数据(最后状态数据+追帧包)\n     * @param startFrameIndex 使用指定的帧索引开始追帧. 不传则默认使用服务端状态同步所在帧索引开始,如果没有状态同步则从头开始\n     */\n    public buildAfterFrames(startFrameIndex?: number): IAfterFrames {\n        //没指定其实,则使用状态同步所在帧索引+1\n        if (startFrameIndex === undefined) startFrameIndex = this._lastStateFrameIndex + 1;\n        let aFrames = this.requestFrames(startFrameIndex);\n        let msg: IAfterFrames = {\n            stateData: this._lastStateData,\n            stateFrameIndex: this._lastStateFrameIndex,\n            afterFrames: aFrames,\n            afterStartFrameIndex: startFrameIndex,\n            afterEndFrameIndex: this._maxSyncFrameIndex,\n            serverSyncFrameRate: this._syncFrameRate,\n        };\n        return msg;\n    }\n\n    /**\n     * 请求帧数组,结果不包含空帧\n     *\n     * @public\n     * @param beginFrameIndex 起始帧索引(包含)\n     * @param endFrameIndex 截止帧索引(包含), 如果没传,则为当前最大帧\n     * @returns 结果不包含空帧\n     */\n    public requestFrames(beginFrameIndex: number, endFrameIndex?: number): IGameSyncFrame[] {\n        let aFrames: IGameSyncFrame[] = [];\n        if (typeof endFrameIndex === 'undefined') endFrameIndex = this._maxSyncFrameIndex;\n        for (let i = beginFrameIndex; i <= endFrameIndex; i++) {\n            let arrIndex = this._allFrameIndexMapArrIndex[i];\n            let frame = typeof arrIndex !== 'undefined' ? this._allFrames[arrIndex] : null;\n            if (frame && frame.frameIndex === i) {\n                aFrames.push(frame);\n            }\n        }\n        return aFrames;\n    }\n\n\n\n}"]}