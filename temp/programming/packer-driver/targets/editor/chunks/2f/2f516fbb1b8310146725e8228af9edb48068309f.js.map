{"version":3,"sources":["file:///E:/CocosProjects/Color/assets/ts-gameframework-master/servers/src/shared/tsgfServer/cluster/ClusterMgr.ts"],"names":["ClusterMgr","BaseConnection","WsServer","apiErrorThenClose","ErrorCodes","Result","EClusterClientType","path","fs","buildNodesHashKey","clusterTypeKey","constructor","clusterServiceProto","getNodesCfg","getTerminalCfg","serverOption","getRedisClient","server","nodes","Map","onNodeConnected","onNodeDisconnected","flows","preApiCallFlow","push","call","prefixCheck","code","AuthUnverified","preMsgCallFlow","logger","error","service","name","JSON","stringify","msg","conn","close","implementApi","apiLogin","listenMsg","msgSyncNodeInfo","postDisconnectFlow","v","nodeDisconnect","buildApiModulePath","apiPath","svcName","match","handlerPath","handlerName","modulePath","resolve","autoImplementApi","serviceProto","output","succ","fail","svc","services","_apiHandlers","apiModulePath","apiModuleDir","dirname","apiModuleName","basename","matchFiles","readdirSync","find","f","extname","handler","getApiHandler","start","stop","clientType","Node","nodeId","Terminal","terminalId","apiClientType","conf","req","clientLoginByTerminal","cfg","c","clusterNodeId","clusterKey","undefined","node","nodeInfo","info","expires","Date","now","nodeConn","set","syncNodeInfoToRedis","terminalKey","get","delete","delNodeInfoToRedis","setHashObject","removeHashValue","getNodeInfos","infos","_","getNodeById","getNodeInfosFromRedis","hashKey","allKv","getHashObjects","key","getNodeInfoFromRedis","getHashObject","assignTask","taskId","taskData","buildErr","ret","sendMsg","isSucc","errMsg","buildSucc","cancelTask"],"mappings":"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","sourcesContent":["import { ApiCall, BaseCall, BaseConnection, BaseServer, BaseServiceType, FlowNode, MsgCall, ServiceProto, TsrpcError, WsServer, WsServerOptions } from \"tsrpc\";\nimport { apiErrorThenClose } from \"../ApiBase\";\nimport { GetRedisClient, IRedisClient } from \"../redisHelper\";\nimport { ErrorCodes, IResult, Result } from \"../../tsgf/Result\";\nimport { IClusterNodeCfg, IClusterTerminalCfg } from \"../../../ServerConfig\";\nimport { ClusterServiceType, EClusterClientType, MsgClusterSyncNodeInfo, ReqClusterLogin, ReqClusterLoginByTerminal, ResClusterLogin } from \"./Models\";\nimport path from 'path';\nimport fs from 'fs';\n\n\ndeclare module 'tsrpc' {\n    export interface BaseConnection {\n        /**连接到集群的客户端类型*/\n        clientType: EClusterClientType;\n        /**如果是节点类型，则有节点id*/\n        nodeId?: string;\n        /**如果是终端类型，则有终端id*/\n        terminalId?: string;\n    }\n}\n\n/**集群节点*/\nexport interface IClusterNode<NodeInfo> {\n    nodeInfo: IClusterNodeInfo<NodeInfo>;\n    nodeConn: BaseConnection<ClusterServiceType>;\n}\n/**集群节点信息*/\nexport interface IClusterNodeInfo<NodeInfo> {\n    clusterNodeId: string;\n    info: NodeInfo;\n    /**过期时间(毫秒级时间戳)*/\n    expires: number;\n}\n\n\n/**\n * 集群管理类\n * @date 2022/4/19 - 16:48:53\n *\n * @class ClusterMgr\n * @typedef {ClusterMgr}\n * @typeParam NodeInfo 节点信息的类型，可自定义\n */\nexport class ClusterMgr<ServiceType extends ClusterServiceType, NodeInfo extends any>{\n\n    /**获取所有可以加入集群的配置 */\n    private getNodesCfg: () => Promise<IClusterNodeCfg[]>;\n    private getTerminalCfg: () => Promise<IClusterTerminalCfg[] | undefined>;\n\n    /**集群类型标识*/\n    protected clusterTypeKey: string;\n\n    /**服务*/\n    protected server: WsServer<ServiceType>;\n\n    /**所有节点，nodeId=>IClusterNode*/\n    protected nodes: Map<string, IClusterNode<NodeInfo>> = new Map<string, IClusterNode<NodeInfo>>();\n\n    protected getRedisClient: GetRedisClient;\n\n    protected onNodeConnected?: (node: IClusterNode<NodeInfo>) => void;\n    protected onNodeDisconnected?: (nodeId: string) => void;\n\n    private static buildNodesHashKey(clusterTypeKey: string) {\n        return `ClusterMgr:${clusterTypeKey}:Nodes`;\n    }\n\n    /**\n     * Creates an instance of ClusterMgr.\n     *\n     * @param clusterTypeKey 集群类型标识，用在各种场合进行区分的，需要唯一定义\n     * @param getNodesCfg\n     * @param serverOption\n     */\n    constructor(\n        clusterServiceProto: ServiceProto<ServiceType>,\n        clusterTypeKey: string,\n        getNodesCfg: () => Promise<IClusterNodeCfg[]>,\n        getTerminalCfg: () => Promise<IClusterTerminalCfg[] | undefined>,\n        serverOption: Partial<WsServerOptions<ServiceType>>,\n        getRedisClient: GetRedisClient) {\n        this.clusterTypeKey = clusterTypeKey;\n        this.getNodesCfg = getNodesCfg;\n        this.getTerminalCfg = getTerminalCfg;\n        this.getRedisClient = getRedisClient;\n        this.server = new WsServer(clusterServiceProto, serverOption);\n\n        //所有消息和api请求，都必须在认证通过之后\n        this.server.flows.preApiCallFlow.push((call) => {\n            if (!this.prefixCheck(call)) {\n                apiErrorThenClose(call, 'need Login before do this', { code: ErrorCodes.AuthUnverified });\n                return;\n            }\n            return call;\n        });\n        this.server.flows.preMsgCallFlow.push((call) => {\n            if (!this.prefixCheck(call)) {\n                call.logger.error(`need Login before do this (${call.service.name}, msg:${JSON.stringify(call.msg)})`);\n                call.conn.close();\n                return;\n            }\n            return call;\n        });\n        this.server.implementApi(\"ClusterLogin\", async (call) => {\n            await this.apiLogin(call);\n        });\n        this.server.listenMsg(\"ClusterSyncNodeInfo\", async call => {\n            await this.msgSyncNodeInfo(call);\n        });\n        this.server.flows.postDisconnectFlow.push((v) => {\n            this.nodeDisconnect(v.conn);\n            return v;\n        });\n    }\n\n    /**\n     * 生成api的模块路径（不含文件后缀）\n     * @param apiPath \n     * @param svcName \n     * @returns api module path \n     */\n    protected buildApiModulePath(apiPath: string, svcName: string): string | null {\n        let match = svcName.match(/^(.+\\/)*(.+)$/);\n        if (!match) {\n            return null;\n        }\n        let handlerPath = match[1] || '';\n        let handlerName = match[2];\n        // try import\n        let modulePath = path.resolve(apiPath, handlerPath, 'Api' + handlerName);\n        return modulePath;\n    }\n\n    protected async autoImplementApi(serviceProto: ServiceProto<BaseServiceType>, apiPath: string) {\n        let output = { succ: [], fail: [] };\n        for (let svc of serviceProto.services) {\n            //@ts-ignore\n            if (this.server._apiHandlers[svc.name]) {\n                continue;\n            }\n            // 如果api文件不存在，则直接忽略！\n            let apiModulePath = this.buildApiModulePath(apiPath, svc.name);\n            if (!apiModulePath) {\n                continue;\n            }\n            let apiModuleDir = path.dirname(apiModulePath);\n            let apiModuleName = path.basename(apiModulePath);\n            let matchFiles = fs.readdirSync(apiModuleDir);\n            if (!matchFiles?.find(f => f === apiModuleName + path.extname(f))) {\n                continue;\n            }\n            //@ts-ignore\n            let { handler } = await this.server.getApiHandler(svc, apiPath, this.server.logger);\n            if (!handler) {\n                continue;\n            }\n            //@ts-ignore\n            this.server.implementApi(svc.name, handler);\n        }\n        return output;\n    }\n\n    public async start() {\n        await this.server.start();\n    }\n    public async stop() {\n        await this.server.stop();\n    }\n\n    private prefixCheck(call: BaseCall<ServiceType>): boolean {\n        if (call.service.name == \"ClusterLogin\") {\n            return true;\n        }\n        if (call.conn.clientType === EClusterClientType.Node) {\n            if (!call.conn.nodeId) {\n                return false;\n            }\n        }\n        if (call.conn.clientType === EClusterClientType.Terminal) {\n            if (!call.conn.terminalId) {\n                return false;\n            }\n        }\n        let apiClientType: EClusterClientType | undefined = call.service.conf?.clientType;\n        if (apiClientType) {\n            if (apiClientType !== call.conn.clientType) return false;\n        }\n        return true;\n    }\n    private async apiLogin(call: ApiCall<ReqClusterLogin, ResClusterLogin, any>) {\n        if (call.req.clientType === EClusterClientType.Terminal) {\n            return await this.clientLoginByTerminal(call);\n        }\n        let req = call.req;\n        let cfg = (await this.getNodesCfg()).find(c => c.clusterNodeId === req.nodeId);\n        if (!cfg) {\n            return await apiErrorThenClose(call, `认证失败！不存在nodeId=${req.nodeId}`);\n        }\n        if (cfg.clusterKey !== req.clusterKey) {\n            return await apiErrorThenClose(call, `认证失败！错误的clusterKey`);\n        }\n        cfg = undefined;\n\n        let node: IClusterNode<NodeInfo> = {\n            nodeInfo: {\n                clusterNodeId: req.nodeId,\n                info: req.nodeInfo,\n                expires: Date.now() + 3 * 60 * 1000,//3分钟过期时间\n            },\n            nodeConn: call.conn,\n        };\n        this.nodes.set(node.nodeInfo.clusterNodeId, node);\n        this.syncNodeInfoToRedis(node.nodeInfo);\n\n        call.conn.clientType = EClusterClientType.Node;\n        call.conn.nodeId = node.nodeInfo.clusterNodeId;\n\n        await call.succ({});\n\n        this.onNodeConnected?.call(this, node);\n    }\n    private async clientLoginByTerminal(call: ApiCall<ReqClusterLogin, ResClusterLogin, any>) {\n        let req = call.req as ReqClusterLoginByTerminal;\n        let cfg = (await this.getTerminalCfg())?.find(c => c.terminalId === req.terminalId);\n        if (!cfg) {\n            return await apiErrorThenClose(call, `认证失败！不存在terminalId=${req.terminalId}`);\n        }\n        if (cfg.terminalKey !== req.terminalKey) {\n            return await apiErrorThenClose(call, `认证失败！错误的clusterKey`);\n        }\n        cfg = undefined;\n        call.conn.clientType = EClusterClientType.Terminal;\n        call.conn.terminalId = req.terminalId;\n        return await call.succ({});\n    }\n    private async msgSyncNodeInfo(call: MsgCall<MsgClusterSyncNodeInfo, any>) {\n        if (!call.conn.nodeId) return;\n        let node = this.nodes.get(call.conn.nodeId);\n        if (!node) {\n            call.logger.error(`连接错误将被踢出`);\n            call.conn.close();\n            return;\n        }\n\n        node.nodeInfo.info = call.msg.nodeInfo;\n        node.nodeInfo.expires = Date.now() + 3 * 60 * 1000;//3分钟过期时间\n        this.syncNodeInfoToRedis(node.nodeInfo);\n    }\n    private nodeDisconnect(conn: BaseConnection<ServiceType>) {\n        if (conn.nodeId) {\n            this.nodes.delete(conn.nodeId);\n            this.delNodeInfoToRedis(conn.nodeId);\n            this.onNodeDisconnected?.call(this, conn.nodeId);\n        }\n    }\n\n    private async syncNodeInfoToRedis(nodeInfo: IClusterNodeInfo<NodeInfo>) {\n        await (await this.getRedisClient()).setHashObject(\n            ClusterMgr.buildNodesHashKey(this.clusterTypeKey),\n            nodeInfo.clusterNodeId, nodeInfo);\n    }\n    private async delNodeInfoToRedis(nodeId: string) {\n        await (await this.getRedisClient()).removeHashValue(`ClusterMgr:${this.clusterTypeKey}:Nodes`, nodeId);\n    }\n\n    public getNodeInfos(): IClusterNodeInfo<NodeInfo>[] {\n        let infos: IClusterNodeInfo<NodeInfo>[] = [];\n        for (let [_, node] of this.nodes) {\n            infos.push(node.nodeInfo);\n        }\n        return infos;\n    }\n    public getNodeById(nodeId: string): IClusterNodeInfo<NodeInfo> | null {\n        return this.nodes.get(nodeId)?.nodeInfo ?? null;\n    }\n\n    /**\n     * 从redis中获取所有节点列表, 分布式时，大厅服务器和游戏服务器管理节点，可能不是同个实例，所以使用本方法来获取\n     *\n     * @public\n     * @typeParam NodeInfo\n     * @param clusterTypeKey 集群类型标识，用在各种场合进行区分的。需要和构造ClussterMgr时的值一致\n     * @returns\n     */\n    public static async getNodeInfosFromRedis<NodeInfo>(\n        clusterTypeKey: string,\n        getRedisClient: (reuseClient: boolean) => Promise<IRedisClient>): Promise<IClusterNodeInfo<NodeInfo>[]> {\n        let hashKey = ClusterMgr.buildNodesHashKey(clusterTypeKey);\n        let allKv = await (await getRedisClient(true))\n            .getHashObjects<IClusterNodeInfo<NodeInfo>>(hashKey);\n        let nodes: IClusterNodeInfo<NodeInfo>[] = [];\n        let now = Date.now();\n        for (let key in allKv) {\n            let nodeInfo = allKv[key];\n            if (nodeInfo.expires < now) continue;\n            nodes.push(nodeInfo);\n        }\n        return nodes;\n    }\n    /**\n     * 从redis中获取指定节点信息, 分布式时，大厅服务器和游戏服务器管理节点，可能不是同个实例，所以使用本方法来获取\n     *\n     * @public\n     * @typeParam NodeInfo\n     * @param clusterTypeKey 集群类型标识，用在各种场合进行区分的。需要和构造ClussterMgr时的值一致\n     * @param clusterNodeId 节点ID\n     * @returns\n     */\n    public static async getNodeInfoFromRedis<NodeInfo>(\n        clusterTypeKey: string,\n        clusterNodeId: string,\n        getRedisClient: (reuseClient: boolean) => Promise<IRedisClient>): Promise<IClusterNodeInfo<NodeInfo> | null> {\n\n        let hashKey = ClusterMgr.buildNodesHashKey(clusterTypeKey);\n        let node = await (await getRedisClient(true))\n            .getHashObject<IClusterNodeInfo<NodeInfo>>(hashKey, clusterNodeId);\n        if (!node) return null;\n        if (node.expires < Date.now()) return null;\n        return node;\n    }\n\n\n    /**\n     * 给节点分配任务\n     *\n     * @public\n     * @typeParam T\n     * @param nodeId\n     * @param taskId 任务ID需要集群内唯一\n     * @param taskData\n     * @returns\n     */\n    public async assignTask<T>(nodeId: string, taskId: string, taskData: T): Promise<IResult<null>> {\n        let node = this.nodes.get(nodeId);\n        if (!node) return Result.buildErr(`nodeId=${nodeId}不存在！`);\n        let ret = await node.nodeConn.sendMsg('AssignTask', {\n            taskId: taskId,\n            taskData: taskData,\n        });\n        if (!ret.isSucc) return Result.buildErr(ret.errMsg);\n        return Result.buildSucc(null);\n    }\n    /**\n     * 给节点取消已经分配的任务\n     *\n     * @public\n     * @typeParam T\n     * @param nodeId\n     * @param taskId 任务ID需要集群内唯一\n     * @param taskData\n     * @returns\n     */\n    public async cancelTask(nodeId: string, taskId: string): Promise<IResult<null>> {\n        let node = this.nodes.get(nodeId);\n        if (!node) return Result.buildErr(`节点ID${nodeId}不存在！`);\n        let ret = await node.nodeConn.sendMsg('CancelTask', {\n            taskId: taskId,\n        });\n        if (!ret.isSucc) return Result.buildErr(ret.errMsg);\n        return Result.buildSucc(null);\n    }\n\n}\n\n"]}