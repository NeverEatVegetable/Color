{"version":3,"sources":["file:///E:/CocosProjects/Color/assets/ts-gameframework-master/servers/src/shared/tsgfServer/match/MatcherFixedTeams.ts"],"names":["MatcherFixedTeams","EMatchFromType","ErrorCodes","Result","arrGroup","arrUpdateItems","arrRemoveItems","arrSum","matcherKey","matchAllReqs","allReqs","joinRoomResults","createRoomResults","roomJoinUsReqs","playerReqs","forEach","r","matchFromType","RoomJoinUs","push","Player","RoomAllPlayers","sortByReqTime","fromInfo","checkReq","matchFromInfo","matchReqs","filter","matchReqGroupKey","length","roomTeamPCount","teamsPlayerIds","map","t","playerIds","ret","matchPlayerReqs","matchRequestPlayerResults","roomJoinUsMatch","matchPlayerCount","matchPlayerResults","currPlayerCount","maxPlayers","joinRoomId","roomId","groupReqs","group","reqs","params","matcherParams","pTeams","fixedTeamList","minPCount","minPlayers","waitReqs","slice","resultsContinueRoomJoinUsMatch","createRoomPara","roomName","ownerPlayerId","isPrivate","fixedTeamInfoList","hasResult","resultCreateRoom","resultJoinRoom","checkReqTeamPlayers","checkReqSelfApply","remainPCount","curr","i","hasRemain","waitFullMatchReqs","fullMatchResult","matchReq","find","matchReqId","pid","playerId","teamId","id","re","fullTeamCounts","min","max","extractTeamCombination","minTeamCounts","teamIndex","req","pCount","splice","undefined","selfReqResult","remainRange","tmpResults","tmpRemainPCount","maxRemain","startRemain","startI","matchReqIds","currI","startReq","c","count","hasCon","includes","e","old","sort","a","b","startMatchTime","procNewMatchReq","newMatchReq","teams","teamParams","buildErr","ParamsError","fixedTeamCount","toString","name","fixedTeamMinPlayers","fixedTeamMaxPlayers","buildSucc","onNewMatchReq","procRet","succ","resultErrCode","code","resultErrMsg","err","onPollMatcherReqs"],"mappings":"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","sourcesContent":["import { EMatchFromType, ISingleMatcherParams, IMatchFromPlayer, IMatchParams, IFixedTeamsMatcherParams } from \"../../tsgf/match/Models\";\nimport { ErrorCodes, IResult, Result } from \"../../tsgf/Result\";\nimport { ITeamInfo } from \"../../tsgf/room/IRoomInfo\";\nimport { arrGroup, arrUpdateItems, arrRemoveItems, arrSum, arrWinner } from \"../../tsgf/Utils\";\nimport { IMatcher } from \"./IMatcher\";\nimport { IMatchRequest, IMatcherExecResult, IMatcherExecResultJoinRoom, IMatcherExecResultCreateRoom, IMatchFromRoomJoinUsOnServer, IMatchRequestPlayerResults, IMatchRequestFromPlayer } from \"./Models\";\n\n\n/**固定队伍匹配器 的匹配属性*/\nexport interface IFixedTeamsMatcherParamsOnServer extends IFixedTeamsMatcherParams {\n    /**只要新匹配进来, 匹配器都会初始化好, 所以匹配中可以直接使用*/\n    fixedTeamList: ITeamInfo[];\n}\n\n/**固定数量的组队匹配器\n * 匹配器参数: 客户端用IFixedTeamsMatcherParams, 服务端用:IFixedTeamsMatcherParamsOnServer\n*/\nexport class MatcherFixedTeams implements IMatcher {\n    public matcherKey: string = 'FixedTeams';\n\n    protected matchAllReqs(allReqs: IMatchRequest[]): IMatcherExecResult {\n\n        let joinRoomResults: IMatcherExecResultJoinRoom[] = [];\n        let createRoomResults: IMatcherExecResultCreateRoom[] = [];\n\n        let roomJoinUsReqs: IMatchRequest[] = [];\n        let playerReqs: IMatchRequestFromPlayer[] = [];\n\n        allReqs.forEach(r => {\n            switch (r.matchFromType) {\n                case EMatchFromType.RoomJoinUs:\n                    roomJoinUsReqs.push(r);\n                    break;\n                case EMatchFromType.Player:\n                case EMatchFromType.RoomAllPlayers:\n                    playerReqs.push(r);\n                    break;\n            }\n        });\n\n        //=====房间招人匹配, 即招人的房间先挑人,挑满后剩下的再看能否匹配成功\n        //排序, 先请求的先满足\n        this.sortByReqTime(roomJoinUsReqs);\n        for (let checkReq of roomJoinUsReqs) {\n            let fromInfo = checkReq.matchFromInfo as IMatchFromRoomJoinUsOnServer;\n            //相同匹配分组的\n            let matchReqs: IMatchRequestFromPlayer[] = playerReqs.filter(r => r.matchReqGroupKey === checkReq.matchReqGroupKey);\n            if (matchReqs.length > 0) {\n                let roomTeamPCount = fromInfo.teamsPlayerIds.map(t => t.playerIds.length);\n                let ret = this.matchPlayerReqs(playerReqs, checkReq, roomTeamPCount, false, matchReqs);\n                if (ret.matchRequestPlayerResults && ret.matchRequestPlayerResults.length > 0) {\n                    let roomJoinUsMatch = true;\n                    let matchPlayerCount = arrSum(ret.matchRequestPlayerResults, r => r.matchPlayerResults.length);\n                    if (fromInfo.currPlayerCount + matchPlayerCount >= checkReq.maxPlayers) {\n                        //如果匹配完玩家满员,则关闭招人匹配\n                        roomJoinUsMatch = false;\n                    }\n                    //匹配成功!\n                    joinRoomResults.push({\n                        joinRoomId: fromInfo.roomId,\n                        matchRequestPlayerResults: ret.matchRequestPlayerResults,\n                        roomJoinUsMatch: roomJoinUsMatch,\n                    });\n                }\n            }\n        }\n\n        //=====玩家匹配\n\n        //根据匹配分组遍历, 组内匹配时间排序, 依次找有没满足minPlayers的匹配\n        let groupReqs = arrGroup(playerReqs, r => r.matchReqGroupKey);\n        for (let group of groupReqs) {\n            let reqs = group[1];\n            if (reqs.length <= 0) continue;\n            //因为同分组下,固定队伍的配置是一致的,只要拿第一个就能获取要求的最小玩家数\n            let params = reqs[0].matcherParams as IFixedTeamsMatcherParamsOnServer;\n            let pTeams = params.fixedTeamList;\n            let minPCount = arrSum(pTeams, t => t.minPlayers);\n            //未被匹配列表\n            let waitReqs = reqs;\n            //整个分组只要剩余匹配数满足最少玩家数,则会继续匹配\n            while (waitReqs.length > 0 && arrSum(waitReqs, r => r.matchFromInfo.playerIds.length) >= minPCount) {\n                let checkReq = waitReqs[0];\n                let roomTeamPCount = pTeams.map(t => 0);\n                let ret = this.matchPlayerReqs(waitReqs, waitReqs[0], roomTeamPCount, false, waitReqs.slice());\n                if (!ret.matchRequestPlayerResults || ret.matchRequestPlayerResults.length <= 0) {\n                    //任何一次匹配没结果,直接停止继续匹配了,后续大概率也是没结果了,等下次轮询\n                    break;\n                }\n                //匹配成功!\n                let roomJoinUsMatch = false;\n                let matchPlayerCount = arrSum(ret.matchRequestPlayerResults, r => r.matchPlayerResults.length);\n                if (matchPlayerCount < checkReq.maxPlayers) {\n                    //如果匹配玩家没满员,则根据配置来决定是否开启招人匹配\n                    roomJoinUsMatch = params?.resultsContinueRoomJoinUsMatch === true;\n                }\n                createRoomResults.push({\n                    createRoomPara: {\n                        roomName: '系统匹配的房间',\n                        ownerPlayerId: '',\n                        maxPlayers: checkReq.maxPlayers,\n                        isPrivate: false,\n                        matcherKey: this.matcherKey,\n                        fixedTeamInfoList: pTeams.slice(),\n                    },\n                    matchRequestPlayerResults: ret.matchRequestPlayerResults.slice(),\n                    roomJoinUsMatch: roomJoinUsMatch,\n                });\n            }\n\n        }\n\n\n        if (joinRoomResults.length <= 0 && createRoomResults.length <= 0) {\n            return { hasResult: false };\n        }\n        return {\n            hasResult: true,\n            resultCreateRoom: createRoomResults,\n            resultJoinRoom: joinRoomResults,\n        };\n\n    }\n\n\n    /**\n     * 匹配筛选出来的玩家列表,成功则移除allReqs里的匹配请求\n     *\n     * @protected\n     * @param allReqs 总匹配请求(匹配中的将从中移除)\n     * @param checkReq 作为匹配主体\n     * @param checkReqTeamPlayers 匹配主体的各队伍玩家人数(即已经有的个队伍玩家数量),长度和固定队伍长度一致\n     * @param checkReqSelfApply 匹配结果是否需要包含checkReq(同时移除)\n     * @param matchPlayerReqs 来自玩家的匹配请求列表, 从中提取中可以匹配成功的请求, 并且本列表需要是一个副本\n     */\n    protected matchPlayerReqs(allReqs: IMatchRequest[],\n        checkReq: IMatchRequest, checkReqTeamPlayers: number[], checkReqSelfApply: boolean,\n        matchPlayerReqs: IMatchRequestFromPlayer[])\n        : {\n            matchRequestPlayerResults?: IMatchRequestPlayerResults[],\n        } {\n\n        this.sortByReqTime(matchPlayerReqs);\n        let matchRequestPlayerResults: IMatchRequestPlayerResults[] = [];\n\n        //匹配器参数(匹配器收到时已经初始化过,确保有不为空)\n        let params = checkReq.matcherParams as IFixedTeamsMatcherParamsOnServer;\n        let remainPCount: number[] = checkReqTeamPlayers.slice();\n        arrUpdateItems(remainPCount, (curr, i) => params.fixedTeamList[i].maxPlayers - curr);\n\n        let hasRemain = false;\n\n        //优先筛选出刚好符合各队伍的剩余人数\n        let waitFullMatchReqs = matchPlayerReqs.slice();\n        let fullMatchResult: IMatchRequestPlayerResults[] = [];\n        for (let i = 0; i < remainPCount.length; i++) {\n            if (remainPCount[i] <= 0) continue;//如果当前队伍直接满员,则忽略\n            //找到玩家数量和剩下数量一致的匹配请求\n            let matchReq = waitFullMatchReqs.find(r => r.matchFromInfo.playerIds.length === remainPCount[i]);\n            if (!matchReq) {\n                //没找到,跳过本队伍,并标记还有没满的\n                hasRemain = true;\n                continue;\n            }\n            fullMatchResult.push({\n                matchReqId: matchReq.matchReqId,\n                matchPlayerResults: matchReq.matchFromInfo.playerIds\n                    .map(pid => { return { playerId: pid, teamId: params.fixedTeamList[i].id } }),\n            });\n            arrRemoveItems(waitFullMatchReqs, r => r.matchReqId === matchReq!.matchReqId);\n        }\n        if (!hasRemain) {\n            //完整匹配成功,刚好所有队伍都匹配max了!, 将结果设置到总结果里\n            matchRequestPlayerResults.push(...fullMatchResult);\n            arrRemoveItems(matchPlayerReqs, r => !!fullMatchResult.find(re=>re.matchReqId=== r.matchReqId));\n        }\n\n        if (hasRemain) {\n            //还有没满的, 继续尝试组合匹配是否有刚好的\n            let fullTeamCounts = params.fixedTeamList.map(t => { return { min: t.maxPlayers, max: t.maxPlayers } });\n            hasRemain = this.extractTeamCombination(params, remainPCount, fullTeamCounts, matchPlayerReqs,\n                matchRequestPlayerResults).hasRemain;\n        }\n\n        if (hasRemain) {\n            //还有没满的, 继续尝试组合匹配符合最低玩家数量要求的\n            let minTeamCounts = params.fixedTeamList.map(t => { return { min: t.minPlayers, max: t.maxPlayers } });\n            hasRemain = this.extractTeamCombination(params, remainPCount, minTeamCounts, matchPlayerReqs,\n                matchRequestPlayerResults).hasRemain;\n            if (!hasRemain) {\n                //满足最低要求了,则开始尽量推满!\n                for (let teamIndex = 0; matchPlayerReqs.length > 0 && teamIndex < remainPCount.length; teamIndex++) {\n                    if (remainPCount[teamIndex] <= 0) continue;//如果当前队伍直接满员,则忽略\n                    //遍历剩余匹配,推满本队玩家\n                    for (let i = 0; remainPCount[teamIndex] > 0 && i < matchPlayerReqs.length; i++) {\n                        let req = matchPlayerReqs[i];\n                        let pCount = req.matchFromInfo.playerIds.length;\n                        if (pCount > remainPCount[teamIndex]) {\n                            //这个匹配包含的玩家数超过剩下的,跳过不要\n                            continue;\n                        }\n                        remainPCount[teamIndex] -= pCount;\n                        matchPlayerReqs.splice(i, 1);//删掉匹配上的\n                        i--;\n                        matchRequestPlayerResults.push({\n                            matchReqId: req.matchReqId,\n                            matchPlayerResults: req.matchFromInfo.playerIds\n                                .map(pid => { return { playerId: pid, teamId: params.fixedTeamList[teamIndex].id } }),\n                        });\n                    }\n                }\n            }\n        }\n\n        if (hasRemain) {\n            //固定队伍有最少玩家没满足的,则本次匹配失败\n            return {\n                matchRequestPlayerResults: undefined,\n            };\n        }\n\n        //这里就匹配成功了\n\n        if (checkReqSelfApply) {\n            //当前匹配数据是否也加入到匹配结果里(房间招人匹配就不需要加入)\n            let selfReqResult: IMatchRequestPlayerResults = {\n                matchReqId: checkReq.matchReqId,\n                matchPlayerResults: [],\n            };\n            if (checkReq.matchFromType === EMatchFromType.Player\n                || checkReq.matchFromType === EMatchFromType.RoomAllPlayers) {\n                //检测请求是来源玩家,则把玩家id也加入到结果中\n                //没有队伍,直接用玩家id生成结果\n                selfReqResult.matchPlayerResults\n                    .push(...checkReq.matchFromInfo.playerIds.map(pid => { return { playerId: pid } }));\n            }\n            //当前这个插入到匹配结果最前面\n            matchRequestPlayerResults.splice(0, 0, selfReqResult);\n        }\n\n        //统一从所有匹配请求中移除匹配成功的\n        arrRemoveItems(allReqs, r => !!matchRequestPlayerResults.find(re => re.matchReqId === r.matchReqId));\n        return {\n            matchRequestPlayerResults,\n        };\n    }\n\n    /**\n     *提取匹配列表中符合数量范围的匹配,成功则加入到结果列表,并返回是否还有剩余一定要填的空位\n     * 失败则不会操作结果和传入的待匹配列表\n     * @protected\n     * @param params\n     * @param remainPCount\n     * @param remainRange\n     * @param matchPlayerReqs\n     * @param matchRequestPlayerResults\n     * @returns\n     */\n    protected extractTeamCombination(params: IFixedTeamsMatcherParamsOnServer,\n        remainPCount: number[], remainRange: { min: number, max: number }[],\n        matchPlayerReqs: IMatchRequestFromPlayer[], matchRequestPlayerResults: IMatchRequestPlayerResults[])\n        : {\n            hasRemain: boolean,\n        } {\n        //复制一个副本,暂时在这里操作,最后如果成功,才移除传入的匹配数组\n        let waitReqs = matchPlayerReqs.slice();\n        //结果对象临时放,最终成功才追加到传入的结果数组\n        let tmpResults: IMatchRequestPlayerResults[] = [];\n        //是否还有空的\n        let hasRemain = false;\n        let tmpRemainPCount = remainPCount.slice();\n        for (let teamIndex = 0; teamIndex < tmpRemainPCount.length; teamIndex++) {\n            let min = remainRange[teamIndex].min;\n            let max = remainRange[teamIndex].max;\n            let maxRemain = max - min;\n\n            if (tmpRemainPCount[teamIndex] <= maxRemain) continue;//如果当前队伍直接满员,则忽略\n            if (waitReqs.length <= 0) {\n                hasRemain = true;\n                break;\n            }\n\n\n            let startRemain = tmpRemainPCount[teamIndex];\n            let reqs = waitReqs.slice();//匹配请求列表复制一份,方便尝试完没发现合适的组合就跳过\n            let startI = 0;\n            let matchReqIds: string[] = [];\n            /*(性能考虑,不做组合算法, 实现一个简单的顺序组合)\n                遍历规则:\n                遍历所有队伍\n                    所有匹配请求,分别拿其中一个元素作为起始,剩余位置重新算\n                        然后n次顺序遍历剩下的,够扣则一直叠加,看是否刚好有满的\n            */\n            do {\n                //本次用startI作为起始量\n                let currI = startI++;\n                let startReq = reqs[currI];\n                matchReqIds = [startReq.matchReqId];\n                //拿currI作为起始,然后重新开始算剩余位置,看能否组合出来\n                tmpRemainPCount[teamIndex] = startRemain - startReq.matchFromInfo.playerIds.length;\n                if (tmpRemainPCount[teamIndex] < 0) {\n                    //这个请求的玩家数量已经超出剩余要的了,跳过这个起始\n                    continue;\n                }\n                //这么刚好不用组合,第一个就符合了\n                if (tmpRemainPCount[teamIndex] <= maxRemain) break;\n\n                //最多遍历剩余位置的遍数\n                for (let c = 0, count = tmpRemainPCount[teamIndex]; c < count; c++) {\n                    let hasCon = false;\n                    //开始遍历除了startI位置的其他匹配\n                    for (let i = 0; i < reqs.length && tmpRemainPCount[teamIndex] > maxRemain; i++) {\n                        let req = reqs[i];\n                        if (req.matchReqId === startReq.matchReqId) continue;\n                        let pCount = req.matchFromInfo.playerIds.length;\n                        if (pCount > tmpRemainPCount[teamIndex]) {\n                            //这个匹配包含的玩家数超过剩下的,跳过不要\n                            continue;\n                        }\n                        //没超过,则扣掉剩下位置\n                        hasCon = true;//标记当前有抵扣\n                        matchReqIds.push(req.matchReqId);\n                        tmpRemainPCount[teamIndex] -= pCount;\n                        reqs.splice(i, 1);//删掉匹配上的\n                        i--;\n                    }\n                    //遍历完成,发现没任何一个可以抵扣的了, 或者成功完整匹配的, 则停止\n                    if (!hasCon || tmpRemainPCount[teamIndex] <= maxRemain) break;\n                }\n                //成功组合上了!\n                if (tmpRemainPCount[teamIndex] <= maxRemain) break;\n\n            } while (tmpRemainPCount[teamIndex] > maxRemain && startI < reqs.length);\n\n            if (tmpRemainPCount[teamIndex]>=0 && tmpRemainPCount[teamIndex] <= maxRemain) {\n                //这个队伍组合满了! 清理数据\n                arrRemoveItems(waitReqs, r => {\n                    if (matchReqIds.includes(r.matchReqId)) {\n                        tmpResults.push({\n                            matchReqId: r.matchReqId,\n                            matchPlayerResults: r.matchFromInfo.playerIds\n                                .map(pid => { return { playerId: pid, teamId: params.fixedTeamList[teamIndex].id } }),\n                        });\n                        return true;\n                    }\n                    return false;\n                });\n            } else {\n                //可惜还是没匹配满\n                hasRemain = true;\n            }\n        }\n\n        if (!hasRemain) {\n            //最后所有队伍都没空位了,则将结果推到外部\n            arrRemoveItems(matchPlayerReqs, r => !!tmpResults.find(e => e.matchReqId === r.matchReqId));\n            matchRequestPlayerResults.push(...tmpResults);\n            arrUpdateItems(remainPCount, (old, i) => tmpRemainPCount[i]);\n        }\n        return {\n            hasRemain,\n        };\n    }\n\n    /**请求按开始匹配时间排序,早的在前面*/\n    protected sortByReqTime(reqs: IMatchRequest[]) {\n        reqs.sort((a, b) => {\n            //返回小于0则a在前\n            return a.startMatchTime - b.startMatchTime;\n        });\n    }\n\n    procNewMatchReq(newMatchReq: IMatchRequest): IResult<null> {\n        //新匹配进来先检查参数和初始化参数!\n        let params = newMatchReq.matcherParams as IFixedTeamsMatcherParamsOnServer;\n        let teams = newMatchReq.teamParams;\n        if (!teams) {\n            return Result.buildErr('固定队伍匹配器必须传入队伍参数!', ErrorCodes.ParamsError);\n        }\n        let fixedTeamList: ITeamInfo[] | null = null;\n        if (teams.fixedTeamInfoList && teams.fixedTeamInfoList.length) {\n            //指定的队伍信息列表\n            fixedTeamList = teams.fixedTeamInfoList.slice();\n        } else if (teams.fixedTeamCount) {\n            //指定固定的队伍数量来生成\n            fixedTeamList = [];\n            for (let i = 0; i < teams.fixedTeamCount; i++) {\n                let id = (i + 1).toString();\n                fixedTeamList.push({\n                    id: (i + 1).toString(),\n                    name: '队伍' + id,\n                    minPlayers: teams.fixedTeamMinPlayers ?? 1,\n                    maxPlayers: teams.fixedTeamMaxPlayers ?? 9,\n                });\n            }\n        }\n        if (!fixedTeamList) {\n            return Result.buildErr('匹配器参数中没有固定队伍的相关配置!', ErrorCodes.ParamsError);\n        }\n\n        if (!params) {\n            params = {\n                fixedTeamList: fixedTeamList,\n                resultsContinueRoomJoinUsMatch: false,\n            };\n            newMatchReq.matcherParams = params;\n        } else {\n            params.fixedTeamList = fixedTeamList;\n        }\n\n        return Result.buildSucc(null);\n\n    }\n\n    onNewMatchReq(newMatchReq: IMatchRequest, allReqs: IMatchRequest[]): IMatcherExecResult {\n        let procRet = this.procNewMatchReq(newMatchReq);\n        if (!procRet.succ) {\n            return {\n                hasResult: true,\n                resultErrCode: procRet.code,\n                resultErrMsg: procRet.err,\n            };\n        }\n        return this.matchAllReqs(allReqs);\n    }\n    onPollMatcherReqs(allReqs: IMatchRequest[]): IMatcherExecResult {\n        return this.matchAllReqs(allReqs);\n    }\n\n}"]}