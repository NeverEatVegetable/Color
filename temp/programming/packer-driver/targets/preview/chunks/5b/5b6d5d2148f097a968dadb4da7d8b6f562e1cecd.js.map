{"version":3,"sources":["file:///E:/CocosProjects/Color/assets/ts-gameframework-master/servers/src/shared/tsgfServer/Queue.ts"],"names":["RedisQueue","constructor","getRedisClient","msgCallbacks","Map","insRedisClient","listen","queueKey","callback","set","ret","getInsRedisClient","blPopObject","get","stopListen","delete","getSelfRedisClient","push","item","rPushObject","pop","lPopObject","blockPop"],"mappings":";;;8BAgDaA,U;;;;;;;;;;;;;;;;;;;;;;AA5Cb;;;AA2CA;4BACaA,U,GAAN,MAAMA,UAAN,CAAmC;AAMtCC,QAAAA,WAAW,CAACC,cAAD,EAAkE;AAAA,eALnEA,cAKmE;AAAA,eAJnEC,YAImE,GAJlB,IAAIC,GAAJ,EAIkB;AAAA,eAFnEC,cAEmE;AACzE,eAAKH,cAAL,GAAsBA,cAAtB;AACH;;AACKI,QAAAA,MAAM,CAAmBC,QAAnB,EAAqCC,QAArC,EAAiF;AAAA;;AAAA;AACzF,YAAA,KAAI,CAACL,YAAL,CAAkBM,GAAlB,CAAsBF,QAAtB,EAAgCC,QAAhC;;AACA,eAAG;AACC;AACA,kBAAIE,GAAG,SAAS,OAAO,KAAI,CAACC,iBAAL,EAAP,EAAiCC,WAAjC,CAAgDL,QAAhD,EAA0D,CAA1D,CAAhB;;AACA,kBAAIG,GAAJ,EAAS;AACLF,gBAAAA,QAAQ,CAACE,GAAD,CAAR;AACH;AACJ,aAND,QAMS,KAAI,CAACP,YAAL,CAAkBU,GAAlB,CAAsBN,QAAtB,CANT;AAFyF;AAS5F;;AACDO,QAAAA,UAAU,CAACP,QAAD,EAAyB;AAC/B,eAAKJ,YAAL,CAAkBY,MAAlB,CAAyBR,QAAzB;AACH;;AAEYS,QAAAA,kBAAkB,GAA0B;AAAA;;AAAA;AACrD,yBAAa,MAAI,CAACd,cAAL,CAAoB,IAApB,CAAb;AADqD;AAExD;;AACYS,QAAAA,iBAAiB,GAA0B;AAAA;;AAAA;AACpD,gBAAI,CAAC,MAAI,CAACN,cAAV,EAA0B;AACtB;AACA,cAAA,MAAI,CAACA,cAAL,SAA4B,MAAI,CAACH,cAAL,CAAoB,KAApB,CAA5B;AACH;;AACD,mBAAO,MAAI,CAACG,cAAZ;AALoD;AAMvD;;AAEKY,QAAAA,IAAI,CAAmBV,QAAnB,EAAqCW,IAArC,EAA6D;AAAA;;AAAA;AACnE,yBAAa,OAAO,MAAI,CAACF,kBAAL,EAAP,EAAkCG,WAAlC,CAAiDZ,QAAjD,EAA2DW,IAA3D,CAAb;AADmE;AAEtE;;AAEKE,QAAAA,GAAG,CAAmBb,QAAnB,EAAwD;AAAA;;AAAA;AAC7D,yBAAa,OAAO,MAAI,CAACS,kBAAL,EAAP,EAAkCK,UAAlC,CAAgDd,QAAhD,CAAb;AAD6D;AAEhE;;AAEKe,QAAAA,QAAQ,CAAmBf,QAAnB,EAAwD;AAAA;;AAAA;AAClE;AACA,yBAAa,OAAO,MAAI,CAACI,iBAAL,EAAP,EAAiCC,WAAjC,CAAgDL,QAAhD,EAA0D,CAA1D,CAAb;AAFkE;AAGrE;;AA7CqC,O","sourcesContent":["\nimport { IRedisClient } from \"./redisHelper\";\n\n\n/**（跨服务器）队列接口*/\nexport interface IQueue {\n\n    /**\n     * 读取并移除队列第一个元素，并json解析为对象，如果队列为空这个返回null\n     *\n     * @typeParam T\n     * @returns\n     */\n    pop<T extends object>(queueKey: string): Promise<T | null>;\n\n    /**\n     * 阻塞的方式读取并移除队列第一个元素，并解析为对象，如果队列为空则会一直阻塞\n     *\n     * @typeParam T\n     * @returns\n     */\n    blockPop<T extends object>(queueKey: string): Promise<T | null>;\n\n    /**\n     * 将一个元素推入队列的最后\n     *\n     * @param item\n     * @returns\n     */\n    push(queueKey: string, item: any): Promise<void>;\n\n    /**\n     * 开始侦听队列，有元素进来时会触发回调, 会阻塞到停止侦听，所以不要await\n     *\n     * @typeParam T\n     * @param callback\n     * @returns\n     */\n    listen<T extends object>(queueKey: string, callback: (item: T) => void): Promise<void>;\n\n    /**\n     * 停止侦听。注意：如果停止时，队列里还有元素，侦听回调可能还会触发一次，防止已经读取出来的数据没触发回调导致“丢包”\n     */\n    stopListen(queueKey: string): void;\n}\n\n\n/**redis队列实现, 需要调用init进行异步初始化*/\nexport class RedisQueue implements IQueue {\n    protected getRedisClient: (reuseClient: boolean) => Promise<IRedisClient>;\n    protected msgCallbacks: Map<string, (item: any) => void> = new Map<string, (item: any) => void>();\n\n    protected insRedisClient?: IRedisClient;\n\n    constructor(getRedisClient: (reuseClient: boolean) => Promise<IRedisClient>) {\n        this.getRedisClient = getRedisClient;\n    }\n    async listen<T extends object>(queueKey: string, callback: (item: T) => void): Promise<void> {\n        this.msgCallbacks.set(queueKey, callback);\n        do {\n            //阻塞读取，1秒超时 （阻塞的命令，需要独占连接，所以使用队列自己的连接\n            let ret = await (await this.getInsRedisClient()).blPopObject<T>(queueKey, 1);\n            if (ret) {\n                callback(ret);\n            }\n        } while (this.msgCallbacks.get(queueKey));\n    }\n    stopListen(queueKey: string): void {\n        this.msgCallbacks.delete(queueKey)\n    }\n\n    public async getSelfRedisClient(): Promise<IRedisClient> {\n        return await this.getRedisClient(true);\n    }\n    public async getInsRedisClient(): Promise<IRedisClient> {\n        if (!this.insRedisClient) {\n            //首次或者之前的已经断开,则全新拷贝一个自己的连接来使用\n            this.insRedisClient = await this.getRedisClient(false);\n        }\n        return this.insRedisClient;\n    }\n\n    async push<T extends object>(queueKey: string, item: T): Promise<void> {\n        return await (await this.getSelfRedisClient()).rPushObject<T>(queueKey, item);\n    }\n\n    async pop<T extends object>(queueKey: string): Promise<T | null> {\n        return await (await this.getSelfRedisClient()).lPopObject<T>(queueKey);\n    }\n\n    async blockPop<T extends object>(queueKey: string): Promise<T | null> {\n        //阻塞的命令，需要独占连接，所以使用全新的获取连接\n        return await (await this.getInsRedisClient()).blPopObject<T>(queueKey, 0);\n    }\n}"]}